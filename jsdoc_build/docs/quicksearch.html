<html>
<head>
</head>
<body style="background: transparent;">
    <script src="scripts/docstrap.lib.js"></script>
    <script src="scripts/lunr.min.js"></script>
    <script src="scripts/fulltext-search.js"></script>

    <script type="text/x-docstrap-searchdb">
    {"rabbit.client.js.html":{"id":"rabbit.client.js.html","title":"Source: rabbit.client.js","body":" Source: rabbit.client.js var amqp = require('amqplib/callback_api'); var util = require('./rabbit.util.js'); var Q = require('q'); var logger = {}; var registeredHandlers = {}; /** * The configuration object that must be passed for an amqp connection string to be properly built * @typedef {Object} customLogger * @property {function} error - custom implementation of customLogger.error * @property {function} info - custom implementation of customLogger.info * @property {function} debug - custom implementation of customLogger.debug * @property {function} fatal - custom implementation of customLogger.fatal * @property {function} trace - custom implementation of customLogger.trace * @property {function} warn - custom implementation of customLogger.warn */ /** * Creates a new Listener instance * @constructor * @param {customLogger} [customLogger = require('./loggerService.js')] - A custom logger object * @example * var subscriber = require('amqplib-lite'); * * // Custom logger passed in * let client = new RabbitClient(customLogObj); * client.handlers = handlers; // when a disconnect happens this handler property will be used to reconnect internally * client.connect(config).then((connection) =&gt; { * client.registerHandlers(handlers, connection); * }).catch(error =&gt; { * logger.error(&quot;Error occurred while bootstrapping queue handlers: &quot;, error); * }); * * // No custom logger pass in * let client = new RabbitClient(); * client.handlers = handlers; // when a disconnect happens this handler property will be used to reconnect internally * client.connect(config).then((connection) =&gt; { * client.registerHandlers(handlers, connection); * }).catch(error =&gt; { * logger.error(&quot;Error occurred while bootstrapping queue handlers: &quot;, error); * }); * */ function Connect(customLogger) { logger = customLogger || require('./loggerService.js'); } /** * The configuration object that must be passed for an amqp connection string to be properly built * @typedef {Object} RabbitHandler * @property {function} handlerFunction - The callback function that messages will be returned and processed on * @property {String} queueConfig - The queue that it will connect to ex &quot;My.First.Queue&quot; * @property {Number} messageRate - The amount of messages that can be received at a time. Once this amount of messages is ack more will come in (if available) */ /** * An array of RabbitHandlers, each rabbit handler has a configuration for a queue to connect to * @typedef {Array&lt;RabbitHandler&gt;} RabbitHandlers */ /** * The configuration object that must be passed for an amqp connection string to be properly built * @typedef {Object} RabbitConfiguration * @property {String} rabbitmqserver - RabbitMqServer string IP or Domain. * @property {Number} rabbitmqport - RabbitMqServer Port. * @property {String} rabbitmqusername - RabbitMqServer username. * @property {String} rabbitmqpassword - RabbitMqServer password. * @property {Number} rabbitheartbeat - optional, sets the client heartbeat with the server. Helps prevent TCP timeouts if rabbit server does not have heartbeat service enabled * @property {String} vhost - RabbitMqServer vhost. */ /** * Generates and processes a single amqp connection for channels to be opened on. * @memberof Listener * @param {RabbitHandlers} handlers - Array of callback handlers WITH configuration for those handlers, one handler per channel * @param {RabbitConfiguration} config - must pass a {@link RabbitConfiguration} object */ Connect.prototype.connect = function (config) { var context = this; return Q.ninvoke(amqp, &quot;connect&quot;, util.buildRabbitMqUrl(config)).then(function (conn) { logger.info(&quot;Connection in progress...&quot;); conn.on(&quot;error&quot;, function (err) { if (err.message !== &quot;Connection closing&quot;) { console.error(&quot;[AMQP] conn error&quot;, err.message); logger.error(&quot;[AMQP] &quot; + err.message); conn.close(); } }); conn.on(&quot;close&quot;, function () { console.error(&quot;[AMQP] reconnecting&quot;); logger.error(&quot;[AMQP] reconnecting&quot;); return setTimeout(function() { context.connect(config).then(function(conn){ context.registerHandlers(context.handlers, conn); }) }, 1000); }); console.log(&quot;[AMQP] connected&quot;); logger.info(&quot;[AMQP] has connected successfully&quot;); return conn; }).catch(function (err) { console.error(&quot;[AMQP]&quot;, err.message); logger.error(&quot;[AMQP] &quot; + err.message); return setTimeout(function() { context.connect(config).then(function(conn){ context.registerHandlers(context.handlers, conn); }) }, 1000); }); }; /** * A Channel object, part of the amqplib. Search amqplib documentation for more information * @typedef {Object} Channel */ /** * Sets up a channel object to be used * @memberof Listener * @param {number} messageRate - number of messages that will be fetched at a time. server must receive ack before it will pass more. * @param {Connection} amqpConn - xxxxxx * @returns {Promise&lt;Channel&gt;} - channel object that can be used to request messages and response */ Connect.prototype.setUpListener = function(messageRate, amqpConn) { var context = this; return Q.ninvoke(amqpConn, 'createChannel').then(function (ch) { ch.on(&quot;error&quot;, function (err) { console.error(&quot;[AMQP] channel error&quot;, err); logger.error(&quot;[AMQP] channel error &quot; + err); }); ch.on(&quot;close&quot;, function () { console.log(&quot;[AMQP] Channel closed&quot;); logger.info(&quot;[AMQP] Channel closed&quot;); context.registerHandlers(registeredHandlers,amqpConn); }); logger.info(&quot;[AMQP] Channel prefetch rate set to &quot; + messageRate); ch.prefetch(messageRate); // limit the number of messages that are read to 1, once the server receives an acknowledgement back it will then send another return ch; }); } /** * This function should be fired when the main amqp connection has been fired * @memberof Listener * @param {array} handlers - Takes in an array of confuration settings to loop through and create queue connections for */ Connect.prototype.registerHandlers = function (handlers, amqpConn) { var context = this; logger.info(&quot;[AMQP] Beginning channel connections&quot;); registeredHandlers = handlers; if(registeredHandlers){ console.log(&quot;[AMQP] Set handlers &quot; ,JSON.stringify(registeredHandlers)); } registeredHandlers.forEach(function (handler) { logger.info(&quot;[AMQP] attempting queue listener handshake for &quot; + handler.queueConfig); context.setUpListener(handler.messageRate, amqpConn) .then(function (ch) { logger.info(&quot;[AMQP] Success handshake complete, listening on &quot; + handler.queueConfig); ch.consume(handler.queueConfig, handler.handlerFunction.bind(ch), {noAck: false}); }).catch(function (err) { if (err) { console.log(err); logger.fatal(&quot;[AMQP] &quot; + err.message); } }); }); }; /** * Used to register new channels on connections that exist, it also checks that the publishing exchange is reachable * @param config * @param amqpConn */ Connect.prototype.registerPublisher = function(config, amqpConn){ return new Promise(function(resolve, reject) { logger.info(&quot;[AMQP] Beginning publisher connections&quot;); logger.info(&quot;[AMQP] attempting publisher handshake for new channel to publish on &quot; + config.publisherExchange); amqpConn.createChannel(function(err, ch) { if (err) { logger.error('no channel'); return reject(err); } ch.checkExchange(config.publisherExchange, function (err, ok) { if (err) { logger.error('[AMQP] error finding exchange ' + config.publisherExchange); } else { logger.info('[AMQP] success finding exchange ' + config.publisherExchange); resolve(ch); } }); }); }); }; module.exports = Connect; × Search results Close "},"rabbit.util.js.html":{"id":"rabbit.util.js.html","title":"Source: rabbit.util.js","body":" Source: rabbit.util.js /** * Module containing util functions for RabbitMq * @module rabbit/util */ /** * @type {Object} * @property {function} buildRabbitMqUrl(String) - build amqp connection string * @property {function} validateJson(String) - validate string is in valid JSON format * @property {function} cleanData(String) - change $type to type */ var service = { buildRabbitMqUrl: buildRabbitMqUrl, validateJson: IsJsonString, cleanData: cleanData }; /** * Builds the RabbitMqUrl connection string * @param {String} config - configuration for connection string * @returns {String} amqpConnString - returns amqp connection string * @example * * var util = require('rabbit.util.js'); * * var config = { * rabbitmqserver: 'localhost', * rabbitmqport: 5672, * rabbitmqusername: 'User_Name', * rabbitmqpassword: 'Pass_Word', * subscribequeue: 'Your.Target.Queue', * vhost: 'YOUR-VHOST' * }; * * var connString = util.buildRabbitMqUrl(config) * console.log(connString); */ function buildRabbitMqUrl(config){ var auth = ''; var heartbeat = config.rabbitheartbeat || 0; if((config.rabbitmqusername + config.rabbitmqpassword) != ''){ auth = config.rabbitmqusername + ':' + config.rabbitmqpassword + '@'; } console.log('amqp://' + auth + config.rabbitmqserver + ':' + config.rabbitmqport + '/' + config.vhost + '?heartbeat=' + heartbeat); return 'amqp://' + auth + config.rabbitmqserver + ':' + config.rabbitmqport + '/' + config.vhost + '?heartbeat=' + heartbeat; } /** * Checks string to see if it is valid JSON * @param {String} str - string to check if is valid JSON * @returns {boolean} - true if string is JSON formatted, false if string is not JSON formatted * @example * * var util = require('rabbit.util.js') * * var testString = '{&quot;employee&quot;:&quot;John&quot;}'; * * console.log(util.IsJsonString(testString)); * // will print true because the string is valid JSON * */ function IsJsonString(str) { try { JSON.parse(str); } catch (e) { console.log('error', e.stack); return false; } return true; } /** * parses through string and replaces &quot;$type&quot; by &quot;type&quot; * @param data {String} - string to replace &quot;$type&quot; by &quot;type&quot; * @returns {string|void|XML} * @example * * var util = require('rabbit.util.js') * * var testString = 'foo $type Bar'; * * console.log(util.cleanData(testString)); * // will print 'foo type Bar' * */ function cleanData(data) { var cleandata = data.replace(&quot;$type&quot;,&quot;type&quot;); return cleandata; } module.exports = service; × Search results Close "},"global.html":{"id":"global.html","title":"Global","body":" Global Type Definitions Channel A Channel object, part of the amqplib. Search amqplib documentation for more information Type: Object Source: rabbit.client.js, line 120 customLogger The configuration object that must be passed for an amqp connection string to be properly built Type: Object Properties: Name Type Description error function custom implementation of customLogger.error info function custom implementation of customLogger.info debug function custom implementation of customLogger.debug fatal function custom implementation of customLogger.fatal trace function custom implementation of customLogger.trace warn function custom implementation of customLogger.warn Source: rabbit.client.js, line 6 RabbitConfiguration The configuration object that must be passed for an amqp connection string to be properly built Type: Object Properties: Name Type Description rabbitmqserver String RabbitMqServer string IP or Domain. rabbitmqport Number RabbitMqServer Port. rabbitmqusername String RabbitMqServer username. rabbitmqpassword String RabbitMqServer password. rabbitheartbeat Number optional, sets the client heartbeat with the server. Helps prevent TCP timeouts if rabbit server does not have heartbeat service enabled vhost String RabbitMqServer vhost. Source: rabbit.client.js, line 61 RabbitHandler The configuration object that must be passed for an amqp connection string to be properly built Type: Object Properties: Name Type Description handlerFunction function The callback function that messages will be returned and processed on queueConfig String The queue that it will connect to ex &quot;My.First.Queue&quot; messageRate Number The amount of messages that can be received at a time. Once this amount of messages is ack more will come in (if available) Source: rabbit.client.js, line 48 RabbitHandlers An array of RabbitHandlers, each rabbit handler has a configuration for a queue to connect to Type: Array.&lt;RabbitHandler&gt; Source: rabbit.client.js, line 56 × Search results Close "},"modules.list.html":{"id":"modules.list.html","title":"Modules","body":" Modules Classes Connect × Search results Close "},"classes.list.html":{"id":"classes.list.html","title":"Classes","body":" Classes Classes Connect × Search results Close "},"index.html":{"id":"index.html","title":"Index","body":" RabbitMQ Integration servicesUse this lightweight library to integrate with rabbitmq. All implementation is built into the listener service. One connection is used per client instance, this connection can open up multiple channels, each channel is a connection to one Queue and willhave a message callback function that you pass into it. The callback function for the has a channel binded tied to it for publishing. DocumentationFeatures Subscriber functionality Publisher functionality 3. Test using mock service (TBA) Usage npm install amqplib-lite Example var subscriber = require('amqplib-lite'); var config = { rabbitmqserver: 'dev.rabbitmq.com', rabbitmqport: '', rabbitmqusername: '', rabbitmqpassword: '', subscribeexchange: 'testExchange', vhost: '' }; // This handler function will response to the ack or reject the message based on business logic. It will also publish to an exchange using the existing // channel connection that exists in the context of the handler. function testProcess1(msg) { var context = this; function publishResponseToExchange(Response){ var publishConfigs = { PUBLISH_EXCHANGE: 'Events.Status.Exchange', PUBLISH_AUDIT_KEY: 'NAT' }; var ok = context.publish(publishConfigs.PUBLISH_EXCHANGE, publishConfigs.PUBLISH_AUDIT_KEY, new Buffer(Response)); if (ok){ console.log('published successfully'); } else { console.log('publish failed'); } } var data = JSON.parse(msg.content.toString()); console.log(JSON.stringify(data)); try { //TODO: Add implementation to update mongo // You can send a message now to an exchange that your processing worked or some other dependent message. publishResponseToExchange('HELLO WORLD'); // Respond that the message has been received and processed to the server, once this is sent the message will be deleted from the Queue context.ack(msg, true); } catch (err) { // you can publish a message on failures now to notify other systems, etc. publishResponseToExchange('I FAILED :('); // reject the message, an error happened during processing context.reject(msg, true); } } var customLogObj = { info : LogMe, error : LogMe, debug : LogMe, fatal : LogMe, trace : LogMe, warn : LogMe }; function LogMe(msg) { console.log('test ' + msg); } var handlers = [{ handlerFunction: testProcess1, queueConfig: 'Your.First.Queue', messageRate: 1 }]; // Custom logger passed in let client = new RabbitClient(logger); client.handlers = handlers; // when a disconnect happens this handler property will be used to reconnect internally client.connect(config).then((connection) =&gt; { client.registerHandlers(handlers, connection); }).catch(error =&gt; { logger.error(&quot;Error occurred while bootstrapping queue handlers: &quot;, error); }); // No custom logger pass in let client = new RabbitClient(); client.handlers = handlers; // when a disconnect happens this handler property will be used to reconnect internally client.connect(config).then((connection) =&gt; { client.registerHandlers(handlers, connection); }).catch(error =&gt; { logger.error(&quot;Error occurred while bootstrapping queue handlers: &quot;, error); });ContactIf you have any questions contact Joseph Bisaillon × Search results Close "},"Connect.html":{"id":"Connect.html","title":"Class: Connect","body":" Class: Connect Connect new Connect(customLogger) Creates a new Listener instance Parameters: Name Type Argument Default Description customLogger customLogger &lt;optional&gt; require('./loggerService.js') A custom logger object Source: rabbit.client.js, line 43 Example var subscriber = require('amqplib-lite'); // Custom logger passed in let client = new RabbitClient(customLogObj); client.handlers = handlers; // when a disconnect happens this handler property will be used to reconnect internally client.connect(config).then((connection) =&gt; { client.registerHandlers(handlers, connection); }).catch(error =&gt; { logger.error(&quot;Error occurred while bootstrapping queue handlers: &quot;, error); }); // No custom logger pass in let client = new RabbitClient(); client.handlers = handlers; // when a disconnect happens this handler property will be used to reconnect internally client.connect(config).then((connection) =&gt; { client.registerHandlers(handlers, connection); }).catch(error =&gt; { logger.error(&quot;Error occurred while bootstrapping queue handlers: &quot;, error); }); Methods registerPublisher(config, amqpConn) Used to register new channels on connections that exist, it also checks that the publishing exchange is reachable Parameters: Name Type Description config amqpConn Source: rabbit.client.js, line 187 × Search results Close "},"module-rabbit_util.html":{"id":"module-rabbit_util.html","title":"Module: rabbit/util","body":" Module: rabbit/util Module containing util functions for RabbitMq Source: rabbit.util.js, line 1 Members &lt;inner&gt; service :Object Type: Object Properties: Name Type Description buildRabbitMqUrl(String) function build amqp connection string validateJson(String) function validate string is in valid JSON format cleanData(String) function change $type to type Source: rabbit.util.js, line 12 Methods &lt;inner&gt; buildRabbitMqUrl(config) Builds the RabbitMqUrl connection string Parameters: Name Type Description config String configuration for connection string Source: rabbit.util.js, line 38 Returns: amqpConnString - returns amqp connection string Type String Example var util = require('rabbit.util.js'); var config = { rabbitmqserver: 'localhost', rabbitmqport: 5672, rabbitmqusername: 'User_Name', rabbitmqpassword: 'Pass_Word', subscribequeue: 'Your.Target.Queue', vhost: 'YOUR-VHOST' }; var connString = util.buildRabbitMqUrl(config) console.log(connString); &lt;inner&gt; cleanData(data) parses through string and replaces &quot;$type&quot; by &quot;type&quot; Parameters: Name Type Description data String string to replace &quot;$type&quot; by &quot;type&quot; Source: rabbit.util.js, line 87 Returns: Type string | void | XML Example var util = require('rabbit.util.js') var testString = 'foo $type Bar'; console.log(util.cleanData(testString)); // will print 'foo type Bar' &lt;inner&gt; IsJsonString(str) Checks string to see if it is valid JSON Parameters: Name Type Description str String string to check if is valid JSON Source: rabbit.util.js, line 63 Returns: true if string is JSON formatted, false if string is not JSON formatted Type boolean Example var util = require('rabbit.util.js') var testString = '{&quot;employee&quot;:&quot;John&quot;}'; console.log(util.IsJsonString(testString)); // will print true because the string is valid JSON × Search results Close "}}
    </script>

    <script type="text/javascript">
        $(document).ready(function() {
            Searcher.init();
        });

        $(window).on("message", function(msg) {
            var msgData = msg.originalEvent.data;

            if (msgData.msgid != "docstrap.quicksearch.start") {
                return;
            }

            var results = Searcher.search(msgData.searchTerms);

            window.parent.postMessage({"results": results, "msgid": "docstrap.quicksearch.done"}, "*");
        });
    </script>
</body>
</html>
